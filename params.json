{"name":"CmdR","tagline":"A simple routing system for command line applications, allowing you to apply a structured way of taking in multiple commands and associating these command with Actions to do useful stuff","body":"# CmdR\r\nCmdR is a simple command routing framework for console applications, giving you a simple way of routing commands to an Action which will perform your apps logic. This helps introduce a separation between your apps logic and the code to drive the input-parse-execute loop.\r\n\r\nCmdR works as a simple input-parse-execute loop where the user enters a command (input) which cmdR will parse and route (parse) to an Action for execution (execute) once the Action has completed cmdR will wait for the user to enter another command and repeat the process\r\n\r\n## CmdR UI\r\n\r\nCmdR now comes with a stand-alone WPF UI which in conjunction with the new plugin functionality allow you to build up your own library of commands by loading them using MEF or Roslyn (c# scripts, which are complied into a dll and loaded at runtime)\r\n\r\n[Get the CmdR app](http://cmdR.github.io/master/theouteredge)\r\n\r\n## NuGet\r\n\r\nTo include the CmdR framework in your own application you can install it using NuGet\r\n\r\n    Install-Package cmdR\r\n\r\n## USAGE\r\n\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            // the class which contains all our logic\r\n            var example = new DOSPromptReplication();\r\n\r\n            // creating the CmdR class passing, specifying the command prompt (> ) to use and a list of exit codes (exit) the user can type to exit the cmdR loop\r\n            // these are the system defaults, so they dont actually need to be passed in\r\n            var cmdR = new CmdR(\"c:\\> \", new string[] { \"exit\" });\r\n            \r\n            // setting up the command routes\r\n            cmdR.RegisterRoute(\"cd path\", example.ChangeDirectory);\r\n            cmdR.RegisterRoute(\"del file\", example.DeleteFile);\r\n\r\n            // registering a route with an optional parameter, optional params are denoted by the ? at the end\r\n            cmdR.RegisterRoute(\"ls filter?\", example.ListDirectory);\r\n\r\n            // registering a route with a lambda\r\n            cmdR.RegisterRoute(\"echo text\", (parameters, console, state) => \r\n                { \r\n                    console.WriteLine(parameters[\"text\"]);\r\n                }));\r\n\r\n            // registering a route with a lambda and cmdR [v1.2.0]\r\n            cmdR.RegisterRoute(\"echo2 text\", (parameters, cmd) => \r\n                { \r\n                    cmd.Console.WriteLine(parameters[\"text\"]);\r\n                }));\r\n\r\n            \r\n            // start the cmdR loop passing in the args as the first command to execute\r\n            cmdR.AutoRegisterCommands();\r\n            cmdR.Run(args);\r\n        }\r\n    }\r\n    \r\n    public class DOSPromptReplication\r\n    {\r\n        private string _directory = @\"c:\\\";\r\n\r\n        public void ChangeDirectory(IDictionary<string, string> param, ICmdRConsole console, ICmdRState state)\r\n        {\r\n            var path = param[\"path\"];\r\n\r\n            if (Directory.Exists(path))\r\n            {\r\n                _directory = path;\r\n            }\r\n            else if (Directory.Exists(_directory + path))\r\n            {\r\n                _directory = _directory + path;\r\n            }\r\n            else console.WriteLine(\"{0} is not a valid directory\", path);\r\n\r\n            if (_directory.Last() != '\\\\')\r\n                _directory = _directory + \"\\\\\";\r\n\r\n            state.CmdPrompt = string.Format(\"{0}\\n> \", _directory);\r\n        }\r\n\r\n        public void ListDirectory(IDictionary<string, string> param, ICmdRConsole console, ICmdRState state)\r\n        {\r\n            foreach(var file in Directory.GetFiles(_directory))\r\n            {\r\n                console.WriteLine(Path.GetFileName(file));\r\n            }\r\n\r\n            foreach (var directory in Directory.GetDirectories(_directory))\r\n            {\r\n                console.WriteLine(directory);\r\n            }\r\n        }\r\n\r\n        public void DeleteFile(IDictionary<string, string> param, ICmdRConsole console, ICmdRState state)\r\n        {\r\n            var file = param[\"file\"];\r\n\r\n            if (File.Exists(file))\r\n            {\r\n                File.Delete(file);\r\n            }\r\n            else if (File.Exists(_directory + file))\r\n            {\r\n                File.Delete(_directory + file);\r\n            }\r\n            else console.WriteLine(\"{0} does not exist\", file);\r\n        }\r\n    }\r\n\r\n\r\n### Example Output\r\n\r\n    c:\\> echo \"hello world!\"\r\n    hello world!\r\n    c:\\> cd c:\\test\r\n    c:\\test> ls\r\n    file1.txt\r\n    file2.txt\r\n    file3.txt\r\n    c:\\test> del file1.txt\r\n    c:\\test> ls\r\n    file2.txt\r\n    file3.txt\r\n    c:\\test> exit\r\n\r\n\r\n## USAGE: Modules\r\n    \r\n    public class DirectoryModule : ICmdRModule\r\n    {\r\n        public DirectoryModule(CmdR cmdR)\r\n        {\r\n            cmdR.RegisterRoute(\"ls search?\", List, \"list all files and directories in the current path with an optional RegEx search pattern\");\r\n            cmdR.RegisterRoute(\"cd path\", ChangeDirectory, \"sets the currently active path, all subsequent commands will be executed within this path\");\r\n        }\r\n\r\n        private void List(IDictionary<string, string> param, CmdR cmd)\r\n        {\r\n            //todo: list directories\r\n        }\r\n\r\n        private void ChangeDirectory(IDictionary<string, string> param, CmdR cmd)\r\n        {\r\n            if (Directory.Exists(param[\"path\"]))\r\n            {\r\n                cmd.State.Variables[\"path\"] = param[\"path\"];\r\n                cmd.State.CmdPrompt = string.Format(\"{0}\\ncmdR>\", param[\"path\"]);\r\n            }\r\n            else cmd.Console.WriteLine(\"{0} does not exists\", param[\"path\"]);\r\n        }\r\n    }\r\n\r\n\r\n## USAGE: Single Command Class\r\n\r\n    public class ChangeDirectoryCommand : ICmdRCommand\r\n    {\r\n        public string Command { get { return \"cd path\"; } }\r\n        public string Description { get { return \"sets the currently active path, all subsequent commands will be executed within this path\"; } }\r\n        \r\n        public void Execute(IDictionary<string, string> param, CmdR cmd)\r\n        {\r\n            if (Directory.Exists(param[\"path\"]))\r\n            {\r\n                cmd.State.Variables[\"path\"] = param[\"path\"];\r\n                cmd.State.CmdPrompt = string.Format(\"{0}\\ncmdR>\", param[\"path\"]);;\r\n            }\r\n            else cmd.Console.WriteLine(\"{0} does not exists\", param[\"path\"]);\r\n        }\r\n    }\r\n\r\n\r\n\r\n## VERSION HISTORY\r\n### 1.3.0\r\nChanged the ICmdRConsle so the Write and WriteLine methods are __params object[] paramters__ instead of __params string[] paramters__ no more .ToString() needed\r\n\r\nChanged the ICmdRState so it has a __IDictionary<string, object> Variables { get; set; }__ this allows you to store variables and share them with other commands\r\n\r\nIntroduced two new Interfaces which allow you to easily register commands automatically, __ICmdRModule__ and __ICmdRCommand__\r\n\r\n**ICmdRModule** allow you to register a single class which implements lots of commands. \r\nThe CmdR class will be passed into the classes constructor allowing you to register your routes there.\r\n\r\n**ICmdRCommand** allows you to register a single class which implements a single command.\r\nThis interface specifies a small interface which will be used by CmdR to automatically register your route.\r\n\r\nSimply implement these interfaces and register them with CmdR by calling cmdR.AutoRegisterCommands()\r\n\r\n### 1.2.0\r\nAdded an additional RegisterRoute which takes in the CmdR class itself. This reduces the amount of params you need to specify while giveing you the same functinality.\r\n\r\n    Action<IDictionary<string, ParameterType>, ICmdR>\r\n\r\nCleaned up the help command so its not so damned ugly... still a little ugly\r\nCleaned the nuget spec aftr finding the -version switch, we don't need multiple nuspec's anymore\r\n\r\n\r\n### 1.1.0\r\nTwo additonal parameters, ICmdRConsole and ICmdRState, have been added to the routes actions, so the action signitures have changed to:\r\n    \r\n    Action<IDictionary<string, ParameterType>, ICmdRConsole, ICmdRState>\r\n\r\n__ICmdRConsole__ abstracts away the reliance on the built in Console class, so we can implement versions for other frameworks in the future, you should use this if you want  to output anything to the screen.\r\n\r\n__ICmdRState__ gives you access to CmdR's internal state, allowing you to modify exit codes, the CmdPrompt and see the current collection of Registered Routes. This was mainly implemented to give you access to the CmdR CmdPrompt setting so you can modify it while the application is running to give feedback to the user. i.e. to show the current path or which database we are currently connected to.\r\n\r\n\r\n## LICENCE\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}